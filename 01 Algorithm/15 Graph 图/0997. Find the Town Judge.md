### [997\. Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/)

Difficulty: **Easy**


In a town, there are `N` people labelled from `1` to `N`.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

1.  The town judge trusts nobody.
2.  Everybody (except for the town judge) trusts the town judge.
3.  There is exactly one person that satisfies properties 1 and 2.

You are given `trust`, an array of pairs `trust[i] = [a, b]` representing that the person labelled `a` trusts the person labelled `b`.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return `-1`.

**Example 1:**

```
Input: N = 2, trust = [[1,2]]
Output: 2
```

**Example 2:**

```
Input: N = 3, trust = [[1,3],[2,3]]
Output: 3
```

**Example 3:**

```
Input: N = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1
```

**Example 4:**

```
Input: N = 3, trust = [[1,2],[2,3]]
Output: -1
```

**Example 5:**

```
Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
Output: 3
```

**Constraints:**

*   `1 <= N <= 1000`
*   `0 <= trust.length <= 10^4`
*   `trust[i].length == 2`
*   `trust[i]` are all different
*   `trust[i][0] != trust[i][1]`
*   `1 <= trust[i][0], trust[i][1] <= N`


#### Solution

Language: **Python3**

```python3
class Solution:
    def findJudge(self, N: int, trust: List[List[int]]) -> int:
        if not trust:
            if N==1:
                return 1
            return -1
        flag=[0]*(N+1)
        flag[0]=1
        dict_n={}
        for arr in trust:
            flag[arr[0]]=1
            if arr[1] not in dict_n:
                dict_n[arr[1]]=[arr[0]]
            else:
                dict_n[arr[1]].append(arr[0])
                
        for k in range(1,len(flag)):
            if flag[k]==0 and k in dict_n and len(dict_n[k])==(N-1):
                return k
        return -1
```