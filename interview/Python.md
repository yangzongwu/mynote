### 如何在Python中管理内存？
python中的内存管理由Python私有堆空间管理。所有Python对象和数据结构都位于私有堆中。程序员无权访问此私有堆。python解释器负责处理这个问题。

Python对象的堆空间分配由Python的内存管理器完成。核心API提供了一些程序员编写代码的工具。

Python还有一个内置的垃圾收集器，它可以回收所有未使用的内存，并使其可用于堆空间。  

### Python中的局部变量和全局变量是什么？
* 全局变量：在函数外或全局空间中声明的变量称为全局变量。这些变量可以由程序中的任何函数访问。
* 局部变量：在函数内声明的任何变量都称为局部变量。此变量存在于局部空间中，而不是全局空间中。

### Python数组和列表有什么区别？
Python中的数组和列表具有相同的存储数据方式。但是，数组只能包含单个数据类型元素，而列表可以包含任何数据类型元素。

### 什么是__init__?

__init__是Python中的方法或者结构。在创建类的新对象/实例时，将自动调用此方法来分配内存。所有类都有__init__方法。

### 什么是lambda函数？

lambda函数也叫匿名函数，该函数可以包含任意数量的参数，但只能有一个执行操作的语句。

### Python中的self是什么？

self是类的实例或对象。在Python中，se
lf包含在第一个参数中。但是，Java中的情况并非如此，它是可选的。它有助于区分具有局部变量的类的方法和属性。init方法中的self变量引用新创建的对象，而在其他方法中，它引用其方法被调用的对象。

### 当Python退出时，为什么不清除所有分配的内存？
当Python退出时，尤其是那些对其他对象具有循环引用的Python模块或者从全局名称空间引用的对象并没有被解除分配或释放。
无法解除分配C库保留的那些内存部分。
退出时，由于拥有自己的高效清理机制，Python会尝试取消分配/销毁其他所有对象。
### 为什么使用* args，** kwargs？
当我们不确定将多少个参数传递给函数，或者我们想要将存储的列表或参数元组传递给函数时，我们使用* args。**当我们不知道将多少关键字参数传递给函数时使用kwargs，或者它可以用于将字典的值作为关键字参数传递。标识符args和kwargs是一个约定，你也可以使用* bob和** billy。

### 深拷贝和浅拷贝有什么区别？
在创建新实例类型时使用浅拷贝，并保留在新实例中复制的值。浅拷贝用于复制引用指针，就像复制值一样。这些引用指向原始对象，并且在类的任何成员中所做的更改也将影响它的原始副本。浅拷贝允许更快地执行程序，它取决于所使用的数据的大小。  
深拷贝用于存储已复制的值。深拷贝不会将引用指针复制到对象。它引用一个对象，并存储一些其他对象指向的新对象。原始副本中所做的更改不会影响使用该对象的任何其他副本。由于为每个被调用的对象创建了某些副本，因此深拷贝会使程序的执行速度变慢。

### 简述解释型和编译型编程语言
* 编译型语言：
   * 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。
   * 特点：
        * 在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件.
   * 执行方式:
        * 源代码 ———> 编译(一次编译) ———>目标代码———>执行(多次执行)———>输出
 
* 解释型语言：
     使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。
  * 特点：
       *    解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。
  * 执行方式:
       *   源代码 ———> 解释器(每次执行都需要解释)———>输出   
 
* 编译型: C c++, c#
* 解释型: python PHP ruby, java



### 简述 yield和yield from关键字。
当一个函数中出现yield关键字的时候，那么这个函数就是一个生成器(generator)。  
函数转化为generator后，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。   
* yield from iterable就是for item in iterable: yield item的语法糖。
* 注意yield from 后面一定是可迭代对象(iterable)。
### 生成器，迭代器
* 生成器(generator)：列表元素可以按照某种算法推算出来（有规律的数组），则可以在循环的过程中不断推算出后续的元素。这种方式就不必创建完整的list，可以节省大量的空间。python中，这种一边循环一边计算的机制，称为生成器：generator。
* 迭代器(Iterator)：可以被next()函数调用并不断返回下一个值得对象称为迭代器(Iterator)。
* 可迭代对象(Iterable)：可以直接作用于for循环的对象（其中包含集合数据类型：list\tuple\dict\set\str；还包含生成器表达式和生成器函数）。可以使用isinstance()判断一个对象是否是Iterable对象。


### 继承
* 在python中，新建的类可以继承一个或多个父类（其他语言只能继承一个父类），父类又可以称为基类或者超类。 
* 仅在python2中才分新式类和经典类，在python3中，无论是否继承object，都默认继承object，即python3中所有类均为新式类。


### is和==的区别
* ==是python标准操作符中的比较操作符，用来比较判断两个对象的value(值)是否相等；
* is也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是id是否相同。

### 谈谈你对面向对象的理解？


### 面向对象深度优先和广度优先是什么？
在子类继承多个父类时，属性查找方式分深度优先和广度优先两种。 
* 当类是经典类时，多继承情况下，在要查找属性不存在时，会按照深度优先方式查找下去。
* 当类是新式类时，多继承情况下，在要查找属性不存在时，会按照广度优先方式查找下去。

### 实例方法，类方法，静态方法
* 实例方法
    * 定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；
    * 调用：只能由实例对象调用。
* 类方法
    * 定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；
    * 调用：实例对象和类对象都可以调用。
* 静态方法
    * 定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；
    * 调用：实例对象和类对象都可以调用。

### 多态
### 请至少列举5个 PEP8 规范
### Python垃圾回收机制？
### 装饰器，
装饰器是一个工厂函数，接受一个函数作为参数，然后返回一个新函数，  
其闭包中包含被装饰的函数。有了装饰器，  
可以提取大量函数中与本身功能无关的类似代码 ( 这块在Flask中用于定义路由的@app.route，就是一个很好的例子)，达到代码重用的目的。  
可应用于插入日志、性能测试、事务处理等方面。  
```python
def deco(func):
    def warpper(*args, **kwargs):
        print(‘start‘)
        func(*args, **kwargs)
        print(‘end‘)
    return warpper

@deco
def myfunc(parameter):
    print("run with %s" % parameter)

myfunc("something")
```

